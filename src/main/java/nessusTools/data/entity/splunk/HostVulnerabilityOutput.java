package nessusTools.data.entity.splunk;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.*;
import com.fasterxml.jackson.databind.node.*;
import nessusTools.client.*;
import nessusTools.data.deserialize.*;
import nessusTools.data.entity.host.*;
import nessusTools.data.entity.lookup.*;
import nessusTools.data.entity.objectLookup.*;
import nessusTools.data.entity.response.*;
import nessusTools.data.entity.scan.*;
import nessusTools.data.entity.template.*;
import nessusTools.data.persistence.*;
import nessusTools.run.*;
import nessusTools.util.*;
import org.hibernate.*;
import org.hibernate.annotations.*;

import javax.persistence.*;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.Table;
import java.sql.*;
import java.util.*;

@Entity(name = "HostVulnerabilityOutput")
@Table(name = "host_vulnerability_output")
@JsonPropertyOrder({"scanner","scan_timestamp", "host", "vulnerability", "plugin", "plugin_error", "plugin_best_guess", "scan"})
public class HostVulnerabilityOutput implements MapLookupPojo<HostVulnerabilityOutput> {
    public static final MapLookupDao<HostVulnerabilityOutput> dao = new MapLookupDao<>(HostVulnerabilityOutput.class);
    public static final String OUTPUT_SCANNER = Main.getConfig().getProperty("output.scanner");

    @Transient
    @JsonGetter("scanner")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public String getScanner() {
        return OUTPUT_SCANNER;
    }

    @Id
    @GeneratedValue(strategy= GenerationType.AUTO, generator="native")
    @GenericGenerator(name = "native",strategy = "native")
    @JsonIgnore
    private int id;

    @Column(name = "scan_timestamp")
    @JsonProperty(value = "scan_timestamp", index =  1)
    @JsonSerialize(using = FriendlyTimestamp.Sql.class)
    private Timestamp scanTimestamp;

    @ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE}, fetch = FetchType.LAZY)
    @JoinColumn(name = "host_id")
    @JsonIgnore
    private HostOutput hostOutput;

    @Transient
    @JsonIgnore
    private ScanHostResponse scanHostResponse;

    @Transient
    @JsonIgnore
    private ScanHost scanHost;

    @Transient
    @JsonIgnore
    private ScanResponse scanResponse;


    @Transient
    @JsonProperty(index = 2)
    @JsonSerialize(using = SummarySerializer.class)
    private final ScanHostSummary host = new ScanHostSummary(this);

    @ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "vulnerability_id")
    @JsonProperty(index = 3)
    private Vulnerability vulnerability;

    @OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "scan_plugin_id")
    @JsonProperty(index = 4)
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private ScanPlugin plugin;

    @Transient
    @JsonProperty(value = "plugin_error", index = 5)
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public String getPluginError() {
        if (this.plugin != null) return null;
        if (this.pluginBestGuess != null) {
            return "NessusTools was unable find a matching Plugin in its cached list of plugins used by this scan, "
                    + "but found another plugin that matches the vulnerability description";
        } else {
            return "NessusTools was unable find a matching Plugin in its cached list of plugins used by this scan, "
                    + "and could not locate another plugin that matches the vulnerability description";
        }
    }

    @ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "plugin_best_guess_id")
    @JsonProperty(value = "plugin (NessusTools best guess)", index = 6)
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private Plugin pluginBestGuess;

    @Transient
    @JsonSerialize(using = SummarySerializer.class)
    @JsonProperty(index = 7)
    private final ScanSummary scan = new ScanSummary(this);

    @Transient
    @JsonIgnore
    @Override
    public void _prepare() {
        this.vulnerability = Vulnerability.dao.getOrCreate(this.vulnerability);
        this.plugin = ScanPlugin.dao.getOrCreate(this.plugin);
        this.pluginBestGuess = Plugin.dao.getOrCreate(this.pluginBestGuess);
    }


    public HostVulnerabilityOutput() { }

    public HostVulnerabilityOutput(ScanResponse scanResponse,
                                    ScanHost scanHost,
                                    ScanHostResponse scanHostResponse,
                                    Vulnerability vulnerability,
                                    HostOutput hostOutput) {

        this.scanResponse = scanResponse;
        this.scanHost = scanHost;
        this.scanHostResponse = scanHostResponse;
        this.vulnerability = vulnerability;
        this.hostOutput = hostOutput;

        findHostAndResponses();

        if (this.vulnerability != null && this.scanResponse != null) {
            this.findPlugin();
        }
    }

    public void findHostAndResponses() {
        if (this.scanHostResponse == null && this.hostOutput != null) {
            ScanHostResponse.dao.holdSession();
            try {
                this.scanHostResponse = ScanHostResponse.dao.getById(this.hostOutput.getId());
                if (this.scanHostResponse != null) {
                    this.scanHostResponse = (ScanHostResponse)Hibernate.unproxy(this.scanHostResponse);
                    this.scanHostResponse.setHost((ScanHost)Hibernate.unproxy(this.scanHostResponse.getHost()));
                }

            } finally {
                ScanHostResponse.dao.releaseSession();
            }

        } else if (this.hostOutput == null && this.scanHostResponse != null) {
            this.hostOutput = HostOutput.dao.getById(this.scanHostResponse.getId());
        }

        if (this.scanHost == null && scanHostResponse != null) {
            this.scanHost = scanHostResponse.getHost();
        }

        if (scanHost != null) {
            this.host.hostId = scanHost.getHostId();
            if (this.scanResponse == null) {
                this.scanResponse = scanHost.getResponse();
            }
        }

        if (scanResponse == null && scanHostResponse != null) {
            this.scanResponse = scanHostResponse.getOrFetchScanResponse();
        }
    }

    @Transient
    @JsonIgnore
    public boolean findPlugin() throws IllegalStateException {
        if (this.id != 0) {
            throw new IllegalStateException("Cannot invoke findPlugin() on a HostVulnerabilityOutput record that has " +
                    "already been inserted into the DB.");
        }

        if (scanResponse == null || vulnerability == null) {
            throw new IllegalStateException("Cannot invoke findPlugin() on a HostVulnerabilityOutput until a " +
                    "ScanResponse and Vulnerability have been set.");
        }

        Integer pluginId = vulnerability.getPluginId();
        String pluginIdStr = pluginId != null ? pluginId.toString() : null;
        PluginName name = this.vulnerability.getPluginName();

        if (scanResponse == null) {
            this.pluginBestGuess = findAltPlugin(pluginId, pluginIdStr, name);
            return this.pluginBestGuess != null;
        }

        Map<ScanPlugin, Integer> candidates = new LinkedHashMap<>();
        int highest = 0;

        List<ScanPlugin> plugins = scanResponse.getPlugins();
        if (plugins != null) {
            for (ScanPlugin plugin : plugins) {
                if (plugin == null) continue;
                int rating = matchPlugin(plugin.getPlugin(), pluginId, pluginIdStr, name);
                if (rating >= 4) {
                    this.plugin = plugin;
                    return true;

                } else if (rating > 0) {
                    candidates.put(plugin, rating);
                    if (rating > highest) {
                        highest = rating;
                    }
                }
            }
        }

        for (Map.Entry<ScanPlugin, Integer> entry : candidates.entrySet()) {
            if (entry.getValue() == highest) {
                this.plugin = entry.getKey();
                return true;
            }
        }
        this.pluginBestGuess = findAltPlugin(pluginId, pluginIdStr, name);
        return this.pluginBestGuess != null;
    }

    private static Plugin findAltPlugin(Integer pluginId,
                              String pluginIdStr,
                              PluginName name) {

        Map<Plugin, Integer> candidates = new LinkedHashMap<>();
        Set<PluginAttributes> checked = new LinkedHashSet<>();
        Var.Int highest = new Var.Int(0);

        if (name != null) {
            List<PluginAttributes> attrs
                    = PluginAttributes.dao.findByPropertyEqual("pluginName", name);

            Plugin result = matchAttributes(attrs, candidates, checked,
                                    highest, pluginId, pluginIdStr, name);

            if (result != null) return result;
        }

        if (pluginIdStr != null) {
            List<Plugin> plgs = Plugin.dao.findByPropertyEqual("pluginId", pluginIdStr);
            for (Plugin plugin : plgs) {
                if (plugin == null) continue;
                if (candidates.containsKey(plugin)) continue;
                int rating = matchPlugin(plugin, pluginId, pluginIdStr, name);
                if (rating >= 4) {
                    return plugin;

                } else if (rating > 0) {
                    candidates.put(plugin, rating);
                    if (rating > highest.value) {
                        highest.value = rating;
                    }
                }
            }
        }

        if (pluginId != null) {
            List<PluginInformation> infos
                    = PluginInformation.dao.findByPropertyEqual("pluginId", pluginId);

            for (PluginInformation info : infos) {
                if (info == null) continue;
                List<PluginAttributes> attrs
                        = PluginAttributes.dao.findByPropertyEqual("pluginInformation", name);

                Plugin result = matchAttributes(attrs, candidates, checked,
                        highest, pluginId, pluginIdStr, name);

                if (result != null) return result;
            }
        }

        for (Map.Entry<Plugin, Integer> entry : candidates.entrySet()) {
            if (entry.getValue() == highest.value) {
                return entry.getKey();
            }
        }
        return null;
    }

    private static Plugin matchAttributes(List<PluginAttributes> attrs,
                                        Map<Plugin, Integer> candidates,
                                        Set<PluginAttributes> checked,
                                        Var.Int highest,
                                        Integer pluginId,
                                        String pluginIdStr,
                                        PluginName name) {

        for (PluginAttributes attr : attrs) {
            if (attr == null) continue;
            if (!checked.add(attr)) continue;
            List<Plugin> plugins = Plugin.dao.findByPropertyEqual("pluginAttributes", attr);
            for (Plugin plugin :plugins) {
                if (plugin == null) continue;
                if (candidates.containsKey(plugin)) continue;
                int rating = matchPlugin(plugin, pluginId, pluginIdStr, name);
                if (rating >= 4) {
                    return plugin;

                } else if (rating > 0) {
                    candidates.put(plugin, rating);
                    if (rating > highest.value) {
                        highest.value = rating;
                    }
                }
            }
        }
        return null;
    }

    private static int matchPlugin(Plugin plugin,
                                Integer pluginId,
                                String pluginIdStr,
                                PluginName name) {

        if (plugin == null) return 0;
        int rating = 0;

        if (pluginIdStr != null && Objects.equals(pluginIdStr, plugin.getPluginId())) {
            rating++;
        }


        if (name != null && Objects.equals(name, plugin.getPluginName())) {
            rating++;
        }

        PluginAttributes attributes = plugin.getPluginAttributes();
        if (attributes == null) return rating;

        PluginInformation info = attributes.getPluginInformation();

        if (info != null && pluginId != null
                && Objects.equals(pluginId, info.getPluginId())) {

            rating++;
        }

        if (name != null && Objects.equals(name, attributes.getPluginName())) {
            rating++;
        }
        return rating;
    }

    @Override
    public void _set(HostVulnerabilityOutput o) {
        this.scanTimestamp = o.scanTimestamp;
        this.hostOutput = o.hostOutput;
        this.scanHostResponse = o.scanHostResponse;
        this.scanHost = o.scanHost;
        this.scanResponse = o.scanResponse;
        this.host.hostId = o.host.hostId;
        this.vulnerability = o.vulnerability;
        this.plugin = o.plugin;
        this.pluginBestGuess = o.pluginBestGuess;
        this.scan.id = o.scan.id;
    }

    @Override
    public boolean _match(HostVulnerabilityOutput o) {
        if (o == this) return true;
        if (o == null) return false;
        return this.hostOutput != null && o.hostOutput != null
                && this.hostOutput.getId() == o.hostOutput.getId()
                && this.hostOutput.getId() != 0
                && this.vulnerability != null && o.vulnerability != null
                && this.vulnerability._match(o.vulnerability);
    }

    @Override
    public Map<String, Object> _getSearchMap() {
        return MakeMap.of(new Object[]
                {"hostOutput", this.hostOutput, "vulnerability", this.vulnerability});
    }

    public static class ScanSummary
            implements SummarySerializer.Summary<Scan, ScanInfo> {

        private ScanSummary(HostVulnerabilityOutput parent) {
            this.parent = parent;
        }

        private final HostVulnerabilityOutput parent;

        private Integer id;

        @Override
        public String getName() {
            return "scan";
        }

        @Override
        public Integer getOptionalId() {
            return this.id;
        }


        private ScanResponse fetchScanResponse() {
            if (parent.scanResponse == null) {
                this.parent.findHostAndResponses();
            }
            if (this.parent.scanResponse != null) {
                this.id = this.parent.scanResponse.getId();
            }
            return this.parent.scanResponse;
        }

        @Override
        public Scan getSummary() {
            ScanResponse scanResponse = this.fetchScanResponse();
            if (scanResponse == null) return null;
            Scan scan = scanResponse.getScan();
            if (scan == null && scanResponse.getId() != 0) {
                scan = Scan.dao.getById(scanResponse.getId());
            }
            return scan;
        }

        @Override
        public ScanInfo getDetails() {
            ScanResponse scanResponse = this.fetchScanResponse();
            if (scanResponse == null) return null;
            ScanInfo info = scanResponse.getInfo();
            if (info == null && scanResponse.getId() != 0) {
                info = ScanInfo.dao.getById(scanResponse.getId());
            }
            return info;
        }

        @Override
        public ExtraJson getOther() {
            if (this.parent.scanResponse == null) return null;
            return this.parent.scanResponse.getExtraJson();
        }
    }

    public static class ScanHostSummary
            implements SummarySerializer.Summary<ScanHostInfo, ScanHost> {

        private ScanHostSummary(HostVulnerabilityOutput parent) {
            this.parent = parent;
        }

        private final HostVulnerabilityOutput parent;

        private Integer hostId;

        @Override
        public String getName() {
            return "host";
        }

        @Override
        public Integer getOptionalId() {
            return hostId;
        }

        @Override
        public ScanHostInfo getSummary() {
            if (parent.scanHostResponse == null) {
                parent.findHostAndResponses();
                if (parent.scanHostResponse == null) return null;
            }

            ScanHostInfo info = this.parent.scanHostResponse.getInfo();
            if (info == null && this.parent.scanHostResponse.getId() != 0) {
                info = ScanHostInfo.dao.getById(this.parent.scanHostResponse.getId());
            }
            return info;
        }

        @Override
        public ScanHost getDetails() {
            ScanHost host = parent.scanHost;
            if (host == null && parent.scanHostResponse == null) {
                parent.findHostAndResponses();
                if (parent.scanHostResponse == null) return null;
            }

            if (host == null) host = this.parent.scanHostResponse.getHost();

            if (host == null && this.parent.scanHostResponse.getId() != 0) {
                host = ScanHost.dao.getById(this.parent.scanHostResponse.getId());
            }

            if (host != null) {
                this.hostId = host.getHostId();
            }

            return host;
        }

        @Override
        public ExtraJson getOther() {
            if (this.parent.scanHostResponse == null) return null;
            return this.parent.scanHostResponse.getExtraJson();
        }
    }

    public int getId() {
        return this.id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public Timestamp getScanTimestamp() {
        return scanTimestamp;
    }

    public void setScanTimestamp(Timestamp scanTimestamp) {
        this.scanTimestamp = scanTimestamp;
    }

    public HostOutput getHostOutput() {
        return hostOutput;
    }

    public void setHostOutput(HostOutput hostOutput) {
        this.hostOutput = hostOutput;
    }

    public ScanHostResponse getScanHostResponse() {
        return scanHostResponse;
    }

    public void setScanHostResponse(ScanHostResponse scanHostResponse) {
        this.scanHostResponse = scanHostResponse;
    }

    public ScanHost getScanHost() {
        return scanHost;
    }

    public void setScanHost(ScanHost scanHost) {
        this.scanHost = scanHost;
    }

    public ScanResponse getScanResponse() {
        return scanResponse;
    }

    public void setScanResponse(ScanResponse scanResponse) {
        this.scanResponse = scanResponse;
    }

    public ScanHostSummary getHost() {
        return host;
    }

    public Vulnerability getVulnerability() {
        return vulnerability;
    }

    public void setVulnerability(Vulnerability vulnerability) {
        this.vulnerability = vulnerability;
    }

    public ScanPlugin getPlugin() {
        return plugin;
    }

    public void setPlugin(ScanPlugin plugin) {
        this.plugin = plugin;
    }

    public Plugin getPluginBestGuess() {
        return pluginBestGuess;
    }

    public void setPluginBestGuess(Plugin pluginBestGuess) {
        this.pluginBestGuess = pluginBestGuess;
    }

    public ScanSummary getScan() {
        return scan;
    }

    @Transient
    @JsonIgnore
    @Override
    public JsonNode toJsonNode() {
        return SplunkOutputMapper.get().valueToTree(this);
    }

    @Transient
    @JsonIgnore
    @Override
    public String toJsonString() throws JsonProcessingException {
        return SplunkOutputMapper.get().writeValueAsString(this);
    }

    @Transient
    @JsonIgnore
    @Override
    public String toString() {
        try {
            return this.toJsonString();
        } catch (JsonProcessingException e) {
            return "toString() could not convert to JSON for '"
                    + super.toString() + "' :\n"
                    + e.getMessage();
        }
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) return false;
        if (o == this) return true;
        if (!Objects.equals(o.getClass(), this.getClass())) return false;

        HostVulnerabilityOutput other = (HostVulnerabilityOutput) o;

        return  (this.getId() == 0 || other.getId() == 0 || this.getId() == other.getId())
                && this._match(other)
                && Objects.equals(this.scanTimestamp, other.scanTimestamp)
                && Objects.equals(this.plugin, other.plugin)
                && Objects.equals(this.pluginBestGuess, other.pluginBestGuess);
    }

    @Override
    public int hashCode() {
        return HostVulnerabilityOutput.class.hashCode() ^ this.id;
    }
}
